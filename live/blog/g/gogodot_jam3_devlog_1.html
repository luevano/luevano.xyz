<!DOCTYPE html>
<html class="theme-dark" lang="en
"
  prefix="og: https://ogp.me/ns#">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="https://static.luevano.xyz/images/icons/favicon.ico">
<title>Creating my Go Godot Jam 3 entry using Godot 3.5 devlog 1 -- Luévano's Blog</title>
  <meta name="description" content="Details on the implementation for the game I created for the Go Godot Jam 3, which theme is Evolution."/>
<link rel="alternate" type="application/rss+xml" href="https://blog.luevano.xyz/rss.xml" title="Luévano's Blog RSS">
    <!-- general style -->
    <link rel="stylesheet" type="text/css" href="https://static.luevano.xyz/css/style.css">
    <link rel="stylesheet" type="text/css" href="https://static.luevano.xyz/fork-awesome/css/fork-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="https://static.luevano.xyz/font-awesome/css/all.min.css">
    <!-- theme related -->
    <script type="text/javascript" src="https://static.luevano.xyz/scripts/theme.js"></script>
    <link id="theme-css" rel="stylesheet" type="text/css" href="https://static.luevano.xyz/css/theme.css">
    <!-- misc functions-->
    <script type="text/javascript" src="https://static.luevano.xyz/scripts/return_top.js"></script>
    <!-- extra -->



    <!-- highlight support for code blocks -->
<script type="text/javascript" src="https://static.luevano.xyz/hl/highlight.min.js"></script>
<script type="text/javascript">
  hljs.initHighlightingOnLoad();
</script>
<link id="code-theme-css" rel="stylesheet" type="text/css" href="https://static.luevano.xyz/hl/styles/nord.min.css">


    <!-- Specific to GDScript -->
    <script type="text/javascript" src="https://static.luevano.xyz/hl/languages/gdscript.min.js"></script>

    <!-- og meta -->
  <meta property="og:title" content="Creating my Go Godot Jam 3 entry using Godot 3.5 devlog 1 -- Luévano's Blog"/>
  <meta property="og:type" content="article"/>
  <meta property="og:url" content="https://blog.luevano.xyz/g/gogodot_jam3_devlog_1.md"/>
  <meta property="og:image" content="https://static.luevano.xyz/images/b/default.png"/>
  <meta property="og:description" content="Details on the implementation for the game I created for the Go Godot Jam 3, which theme is Evolution."/>
  <meta property="og:locale" content="en"/>
  <meta property="og:site_name" content="Luévano's Blog"/>
  </head>

  <body>
    <header>
<nav>
  <ul>
    <li>
      <a href="https://luevano.xyz/"><i class="fas fa-home" alt="Home"></i><span>Home</span></a>
    </li>

    <li>
      <a href="https://blog.luevano.xyz/"><i class="fas fa-book-open" alt="Blog"></i><span>Blog</span></a>
    </li>

    <li>
      <a href="https://art.luevano.xyz/"><i class="fas fa-paint-brush" alt="Art"></i><span>Art</span></a>
    </li>

    <li><i class="fab fa-git" alt="Git"></i><span>Git</span>
      <ul>
        <li><a href="https://git.luevano.xyz/" target="_blank"><i class="fab fa-git-alt" alt="Git-alt"></i></a></li>

        <li><a href="https://github.com/luevano" target="_blank"><i class="fab fa-github" alt="Github"></i></a></li>

        <li><a href="https://gitlab.com/dluevano" target="_blank"><i class="fab fa-gitlab" alt="Gitlab"></i></a></li>
      </ul>
    </li>

    <li><i class="fas fa-box-open" alt="Stuff"></i><span>Stuff</span>
      <ul>
        <li><a href="https://gb.luevano.xyz/"><i class="fas fa-gamepad" alt="Gameboy"></i><span>Gameboy</span></a></li>
      </ul>
    </li>
  </ul>
</nav>

<button class="theme-switcher" onclick="toggleTheme()"><i class="fas fa-moon"></i><i class="fas fa-sun"></i></button>

    </header>

    <main>
      <div class="return-top">
        <button class="return-top" onclick="returnTop()" id="returnTopButton">
        <i class="fas fa-arrow-up" alt="Return to top"></i>
        </button>
      </div>
  <h1>Creating my Go Godot Jam 3 entry using Godot 3.5 devlog 1</h1>

  <p>The jam&rsquo;s theme is Evolution and all the details are listed <a href="https://itch.io/jam/go-godot-jam-3">here</a>. <del>This time I&rsquo;m logging as I go, so there might be some changes to the script or scenes along the way.</del> <ins>I couldn&rsquo;t actually do this, as I was running out of time</ins>. Note that I&rsquo;m not going to go into much details, the obvious will be ommitted.</p>
<p>I wanted to do a <em>Snake</em> clone, and I&rsquo;m using this jam as an excuse to do it and add something to it. The features include:</p>
<ul>
<li>Snakes will pass their stats in some form to the next snakes.</li>
<li>Non-grid snake movement. I just hate the grid constraint, so I wanted to make it move in any direction.</li>
<li>Depending on the food you eat, you&rsquo;ll gain new mutations/abilities <del>and the more you eat the more that mutation develops</del> <ins>didn&rsquo;t have time to add this feature, sad</ins>.</li>
<li>Procedural map creation.</li>
</ul>
<p>I created this game using <em>Godot 3.5-rc3</em>. You can find the source code in my GitHub <a href="https://github.com/luevano/gogodot_jam3">here</a> which at the time of writing this it doesn&rsquo;t contain any exported files, for that you can go ahead and play it in your browser at <a href="https://lorentzeus.itch.io/snake-tronic">itch.io</a>, which you can find below:</p>
<p style="text-align:center"><iframe src="https://itch.io/embed/1562701?dark=true" width="208" height="167" frameborder="0"><a href="https://lorentzeus.itch.io/snake-tronic">Snake-tronic by Lorentzeus</a></iframe></p>

<p>You can also find the jam entry <a href="https://itch.io/jam/go-godot-jam-3/rate/1562701">here</a>.</p>
<p>Similarly with the my FlappyBird clone, I plan to update this to a better state.</p>
<h2 id="table-of-contents">Table of contents<a class="headerlink" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<div class="toc">
<ul>
<li><a href="#table-of-contents">Table of contents</a></li>
<li><a href="#initial-setup">Initial setup</a></li>
<li><a href="#assets">Assets</a></li>
<li><a href="#the-snake">The snake</a><ul>
<li><a href="#basic-movement">Basic movement</a></li>
<li><a href="#setting-up-path-following">Setting up path following</a></li>
<li><a href="#define-body-parts-for-the-snake">Define body parts for the snake</a></li>
<li><a href="#adding-body-parts">Adding body parts</a></li>
<li><a href="#fix-on-body-segments-following-head">Fix on body segments following head</a></li>
</ul>
</li>
<li><a href="#the-food">The food</a></li>
<li><a href="#za-warudo-the-world">Za warudo! (The world)</a><ul>
<li><a href="#food-placement">Food placement</a></li>
</ul>
</li>
<li><a href="#stats-clas-and-loadingsaving-data">Stats clas and loading/saving data</a><ul>
<li><a href="#stats-class">Stats class</a></li>
<li><a href="#loadsave-data">Load/save data</a></li>
</ul>
</li>
<li><a href="#scoring">Scoring</a></li>
<li><a href="#snake-redesigned-with-the-state-machine-pattern">Snake redesigned with the state machine pattern</a></li>
<li><a href="#other-minor-stuff">Other minor stuff</a></li>
<li><a href="#final-notes">Final notes</a></li>
</ul>
</div>
<h2 id="initial-setup">Initial setup<a class="headerlink" href="#initial-setup" title="Permanent link">&para;</a></h2>
<p>Again, similar to the <a href="https://blog.luevano.xyz/g/flappybird_godot_devlog_1.html">FlappyBird</a> clone I created, I&rsquo;m using the directory structure I wrote about on <a href="https://blog.luevano.xyz/g/godot_project_structure.html">Godot project structure</a> with slight modifications to test things out. Also using similar <em>Project settings</em> as those from the <em>FlappyBird</em> clone like the pixel art texture imports, keybindings, layers, etc..</p>
<p>I&rsquo;ve also setup <a href="https://github.com/bram-dingelstad/godot-gifmaker">GifMaker</a>, with slight modifications as the <em>AssetLib</em> doesn&rsquo;t install it correctly and contains unnecessry stuff: moved necessary files to the <code>res://addons</code> directory, deleted test scenes and files in general, and copied the license to the <code>res://docs</code> directory. Setting this up was a bit annoying because the tutorial it&rsquo;s bad (with all due respect). I might do a separate entry just to explain how to set it up, because I couldn&rsquo;t find it anywhere other than by inspecting some of the code/scenes. <ins>I ended up leaving this disabled in the game as it hit the performance by a lot, but it&rsquo;s an option I&rsquo;ll end up researching more</ins>.</p>
<p>This time I&rsquo;m also going to be using an <a href="https://www.gdquest.com/docs/guidelines/best-practices/godot-gdscript/event-bus/">Event bus</a> singleton (which I&rsquo;m going to just call <em>Event</em>) as managing signals was pretty annoying on my last project; as well as a <em>Global</em> singleton for essential stuff so I don&rsquo;t have to do as many cross references between nodes/scenes.</p>
<h2 id="assets">Assets<a class="headerlink" href="#assets" title="Permanent link">&para;</a></h2>
<p>This time I&rsquo;ll be creating my own assets in <a href="https://www.aseprite.org/">Aseprite</a>, wont be that good, but enough to prototype and get things going.</p>
<p>Other than that I used few key sprites from <a href="https://vryell.itch.io/">vryell</a>: <a href="https://vryell.itch.io/controller-keyboard-icons">Controller &amp; Keyboard Icons</a> and a font from <a href="https://datagoblin.itch.io/">datagoblin</a>: <a href="https://datagoblin.itch.io/monogram">Monogram</a>.</p>
<h2 id="the-snake">The snake<a class="headerlink" href="#the-snake" title="Permanent link">&para;</a></h2>
<p>This is the most challenging part in my opinion as making all the body parts follow the head in a user defined path it&rsquo;s kinda hard. I tried with like 4-5 options and the one I&rsquo;m detailing here is the only one that worked as I wanted for me. This time the directory structure I&rsquo;m using is the following:</p>
<figure id="__yafg-figure-32">
<img alt="FileSystem - Snake dir structure" src="https://static.luevano.xyz/images/g/gogodot_jam3/file_system_snake_dir_structure.png" title="FileSystem - Snake dir structure">
<figcaption>FileSystem - Snake dir structure</figcaption>
</figure>
<h3 id="basic-movement">Basic movement<a class="headerlink" href="#basic-movement" title="Permanent link">&para;</a></h3>
<p>The most basic thing is to move the head, this is what we have control of. Create a scene called <code>Head.tscn</code> and setup the basic <em>KinematicBody2D</em> with it&rsquo;s own <em>Sprite</em> and <em>CollisionShape2D</em> (I used a small circle for the tip of the head), and set the <em>Collision Layer/Mask</em> accordingly, for now just <code>layer = bit 1</code>. And all we need to do, is keep moving the snake forwards and be able to rotate left or right. Created a new script called <code>head.gd</code> attached to the root (<em>KinematicBody2D</em>) and added:</p>
<pre><code class="language-gdscript">extends KinematicBody2D

enum {
    LEFT=-1,
    RIGHT=1
}

var velocity: Vector2 = Vector2.ZERO
var _direction: Vector2 = Vector2.UP


func _physics_process(delta: float) -&gt; void:
    if Input.is_action_pressed(&quot;move_left&quot;):
        _rotate_to(LEFT)
    if Input.is_action_pressed(&quot;move_right&quot;):
        _rotate_to(RIGHT)

    velocity = _direction * Global.SNAKE_SPEED

    velocity = move_and_slide(velocity)
    _handle_time_elapsed(delta)


func _rotate_to(direction: int) -&gt; void:
    rotate(deg2rad(direction * Global.SNAKE_ROT_SPEED * get_physics_process_delta_time()))
    _direction = _direction.rotated(deg2rad(direction * Global.SNAKE_ROT_SPEED * get_physics_process_delta_time()))
</code></pre>
<p>After tunning all the necessary parameters you should get something like this:</p>
<figure id="__yafg-figure-33">
<img alt="Snake - Basic movement (left and right controls)" src="https://static.luevano.xyz/images/g/gogodot_jam3/snake_basic_movement.gif" title="Snake - Basic movement (left and right controls)">
<figcaption>Snake - Basic movement (left and right controls)</figcaption>
</figure>
<h3 id="setting-up-path-following">Setting up path following<a class="headerlink" href="#setting-up-path-following" title="Permanent link">&para;</a></h3>
<p>To move other snake parts by following the snake head the only solution I found was to use the <em>Path2D</em> and <em>PathFollow2D</em> nodes. <em>Path2D</em> basically just handles the curve/path that <em>PathFollow2D</em> will use to move its child node; and I say &ldquo;child node&rdquo; in singular&hellip; as <em>PathFollow2D</em> can only handle one damn child, all the other ones will have weird transformations and/or rotations. So, the next thing to do is to setup a way to compute (and draw so we can validate) the snake&rsquo;s path/curve.</p>
<p>Added the signal <code>snake_path_new_point(coordinates)</code> to the <em>Event</em> singleton and then add the following to <code>head.gd</code>:</p>
<pre><code class="language-gdscript">var _time_elapsed: float = 0.0

# using a timer is not recommended for &lt; 0.01
func _handle_time_elapsed(delta: float) -&gt; void:
    if _time_elapsed &gt;= Global.SNAKE_POSITION_UPDATE_INTERVAL:
        Event.emit_signal(&quot;snake_path_new_point&quot;, global_position)
        _time_elapsed = 0.0
    _time_elapsed += delta
</code></pre>
<p>This will be pinging the current snake head position every <code>0.01</code> seconds (defined in <em>Global</em>). Now create a new scene called <code>Snake.tscn</code> which will contain a <em>Node2D</em>, a <em>Path2D</em> and an instance of <em>Head</em> as its childs. Create a new script called <code>snake.gd</code> attached to the root (<em>Node2D</em>) with the following content:</p>
<pre><code class="language-gdscript">class_name Snake
extends Node2D

onready var path: Path2D = $Path

func _ready():
    Event.connect(&quot;snake_path_new_point&quot;, self, &quot;_on_Head_snake_path_new_point&quot;)


func _draw() -&gt; void:
    if path.curve.get_baked_points().size() &gt;= 2:
        draw_polyline(path.curve.get_baked_points(), Color.aquamarine, 1, true)


func _on_Head_snake_path_new_point(coordinates: Vector2) -&gt; void:
    path.curve.add_point(coordinates)
    # update call is to draw curve as there are new points to the path's curve
    update()
</code></pre>
<p>With this, we&rsquo;re now populating the <em>Path2D</em> curve points with the position of the snake head. You should be able to see it because of the <code>_draw</code> call. If you run it you should see something like this:</p>
<figure id="__yafg-figure-34">
<img alt="Snake - Basic movement with path" src="https://static.luevano.xyz/images/g/gogodot_jam3/snake_basic_movement_with_path.gif" title="Snake - Basic movement with path">
<figcaption>Snake - Basic movement with path</figcaption>
</figure>
<h3 id="define-body-parts-for-the-snake">Define body parts for the snake<a class="headerlink" href="#define-body-parts-for-the-snake" title="Permanent link">&para;</a></h3>
<p>At this point the only thing to do is to add the corresponding next body parts and tail of the snake. To do so, we need a <em>PathFollow2D</em> to use the live-generating <em>Path2D</em>, the only caveat is that we need one of these per body part/tail (this took me hours to figure out, <em>thanks documentation</em>).</p>
<p>Create a new scene called <code>Body.tscn</code> with a <em>PathFollow2D</em> as its root and an <em>Area2D</em> as its child, then just add the necessary <em>Sprite</em> and <em>CollisionShap2D</em> for the <em>Area2D</em>, I&rsquo;m using <code>layer = bit 2</code> for its collision. Create a new script called <code>generic_segment.gd</code> with the following code:</p>
<pre><code class="language-gdscript">extends PathFollow2D

export(String, &quot;body&quot;, &quot;tail&quot;) var TYPE: String = &quot;body&quot;


func _physics_process(delta: float) -&gt; void:
    offset += Global.SNAKE_SPEED * delta
</code></pre>
<p>And this can be attached to the <em>Body</em>&lsquo;s root node (<em>PathFollow2D</em>), no extra setup needed. Repeat the same steps for creating the <code>Tail.tscn</code> scene and when attaching the <code>generic_segment.gd</code> script just configure the <code>Type</code> parameter to <code>tail</code> in the GUI (by selecting the node with the script attached and editing in the <em>Inspector</em>).</p>
<h3 id="adding-body-parts">Adding body parts<a class="headerlink" href="#adding-body-parts" title="Permanent link">&para;</a></h3>
<p>Now it&rsquo;s just a matter of handling when to add new body parts in the <code>snake.gd</code> script. For now I&rsquo;ve only setup for adding body parts to fulfill the initial length of the snake (this doesn&rsquo;t include the head or tail). The extra code needed is the following:</p>
<pre><code class="language-gdscript">export(PackedScene) var BODY_SEGMENT_NP: PackedScene
export(PackedScene) var TAIL_SEGMENT_NP: PackedScene

var current_body_segments: int = 0
var max_body_segments: int = 1


func _add_initial_segment(type: PackedScene) -&gt; void:
    if path.curve.get_baked_length() &gt;= (current_body_segments + 1.0) * Global.SNAKE_SEGMENT_SIZE:
        var _temp_body_segment: PathFollow2D = type.instance()
        path.add_child(_temp_body_segment)
        current_body_segments += 1


func _on_Head_snake_path_new_point(coordinates: Vector2) -&gt; void:
    path.curve.add_point(coordinates)
    # update call is to draw curve as there are new points to the path's curve
    update()

    # add the following lines
    if current_body_segments &lt; max_body_segments:
        _add_initial_segment(BODY_SEGMENT_NP)
    elif current_body_segments == max_body_segments:
        _add_initial_segment(TAIL_SEGMENT_NP)
</code></pre>
<p>Select the <em>Snake</em> node and add the <em>Body</em> and <em>Tail</em> scene to the parameters, respectively. Then when running you should see something like this:</p>
<figure id="__yafg-figure-35">
<img alt="Snake - Basic movement with all body parts" src="https://static.luevano.xyz/images/g/gogodot_jam3/snake_basic_movement_added_body_parts.gif" title="Snake - Basic movement with all body parts">
<figcaption>Snake - Basic movement with all body parts</figcaption>
</figure>
<p>Now, we need to handle adding body parts after the snake is complete and already moved for a bit, this will require a queue so we can add part by part in the case that we eat multiple pieces of food in a short period of time. For this we need to add some signals: <code>snake_adding_new_segment(type)</code>, <code>snake_added_new_segment(type)</code>, <code>snake_added_initial_segments</code> and use them when makes sense. Now we need to add the following:</p>
<pre><code class="language-gdscript">var body_segment_stack: Array
var tail_segment: PathFollow2D
# didn't konw how to name this, basically holds the current path lenght
#   whenever the add body segment, and we use this stack to add body parts
var body_segment_queue: Array
</code></pre>
<p>As well as updating <code>_add_initial_segment</code> with the following so it adds the new segment on the specific variable:</p>
<pre><code class="language-gdscript">if _temp_body_segment.TYPE == &quot;body&quot;:
    body_segment_stack.append(_temp_body_segment)
else:
    tail_segment = _temp_body_segment
</code></pre>
<p>Now that it&rsquo;s just a matter of creating the segment queue whenever a new segment is needed, as well as adding each segment in a loop whenever we have items in the queue and it&rsquo;s a good distance to place the segment on. These two things can be achieved with the following code:</p>
<pre><code class="language-gdscript"># this will be called in _physics_process
func _add_new_segment() -&gt; void:
    var _path_length_threshold: float = body_segment_queue[0] + Global.SNAKE_SEGMENT_SIZE
    if path.curve.get_baked_length() &gt;= _path_length_threshold:
        var _removed_from_queue: float = body_segment_queue.pop_front()
        var _temp_body_segment: PathFollow2D = BODY_SEGMENT_NP.instance()
        var _new_body_offset: float = body_segment_stack.back().offset - Global.SNAKE_SEGMENT_SIZE

        _temp_body_segment.offset = _new_body_offset
        body_segment_stack.append(_temp_body_segment)
        path.add_child(_temp_body_segment)
        tail_segment.offset = body_segment_stack.back().offset - Global.SNAKE_SEGMENT_SIZE

        current_body_segments += 1


func _add_segment_to_queue() -&gt; void:
    # need to have the queues in a fixed separation, else if the eating functionality
    #   gets spammed, all next bodyparts will be spawned almost at the same spot
    if body_segment_queue.size() == 0:
        body_segment_queue.append(path.curve.get_baked_length())
    else:
        body_segment_queue.append(body_segment_queue.back() + Global.SNAKE_SEGMENT_SIZE)
</code></pre>
<p>With everything implemented and connected accordingly then we can add segments on demand (for testing I&rsquo;m adding with a key press), it should look like this:</p>
<figure id="__yafg-figure-36">
<img alt="Snake - Basic movement with dynamic addition of new segments" src="https://static.luevano.xyz/images/g/gogodot_jam3/snake_basic_movement_with_dynamic_segments.gif" title="Snake - Basic movement with dynamic addition of new segments">
<figcaption>Snake - Basic movement with dynamic addition of new segments</figcaption>
</figure>
<p>For now, this should be enough, I&rsquo;ll add more stuff as needed as I go. Last thing is that after finished testing that the movement felt ok, I just added a way to stop the snake whenever it collides with itself by using the following code (and the signal <code>snake_segment_body_entered(body)</code>) in a <code>main.gd</code> script that is the entry point for the game:</p>
<pre><code class="language-gdscript">func _snake_disabled(on_off: bool) -&gt; void:
    _snake.propagate_call(&quot;set_process&quot;, [on_off])
    _snake.propagate_call(&quot;set_process_internal&quot;, [on_off])
    _snake.propagate_call(&quot;set_physics_process&quot;, [on_off])
    _snake.propagate_call(&quot;set_physics_process_internal&quot;, [on_off])
    _snake.propagate_call(&quot;set_process_input&quot;, [on_off])
</code></pre>
<p>Which will stop the snake node and all children.</p>
<h3 id="fix-on-body-segments-following-head">Fix on body segments following head<a class="headerlink" href="#fix-on-body-segments-following-head" title="Permanent link">&para;</a></h3>
<p>After a while of testing and developing, I noticed that sometimes the head &ldquo;detaches&rdquo; from the body when a lot of rotations happen (moving the snake left or right), because of how imprecise the <em>Curve2D</em> is. To do this I just send a signal (<code>snake_rotated</code>) whenever the snake rotates and make a small correction (in <code>generic_segment.gd</code>):</p>
<pre><code class="language-gdscript">func _on_snake_rotated() -&gt; void:
    offset -= 0.75 * Global.SNAKE_SPEED * pow(get_physics_process_delta_time(), 2)
</code></pre>
<p>This is completely random, I tweaked it manually after a lot of iterations.</p>
<h2 id="the-food">The food<a class="headerlink" href="#the-food" title="Permanent link">&para;</a></h2>
<p>For now I just decided to setup a simple system to see everything works fine. The idea is to make some kind of generic food node/scene and a &ldquo;food manager&rdquo; to spawn them, for now in totally random locations. For this I added the following signals: <code>food_placing_new_food(type)</code>, <code>food_placed_new_food(type)</code> and <code>food_eaten(type)</code>.</p>
<p>First thing is creating the <code>Food.tscn</code> which is just an <em>Area2D</em> with its necessary children with an attached script called <code>food.gd</code>. The script is really simple:</p>
<pre><code class="language-gdscript">class_name Food # needed to access Type enum outside of the script, this registers this script as a node
extends Area2D

enum Type {
    APPLE
}

var _type_texture: Dictionary = {
    Type.APPLE: preload(&quot;res://entities/food/sprites/apple.png&quot;)
}

export(Type) var TYPE
onready var _sprite: Sprite = $Sprite


func _ready():
    connect(&quot;body_entered&quot;, self, &quot;_on_body_entered&quot;)
    _sprite.texture = _type_texture[TYPE]


func _on_body_entered(body: Node) -&gt; void:
    Event.emit_signal(&quot;food_eaten&quot;, TYPE)
    queue_free()
</code></pre>
<p>Then this <code>food_eaten</code> signal is received in <code>snake.gd</code> to add a new segment to the queue.</p>
<p>Finally, for the food manager I just created a <code>FoodManager.tscn</code> with a <em>Node2D</em> with an attached script called <code>food_manager.gd</code>. To get a random position:</p>
<pre><code class="language-gdscript">func _get_random_pos() -&gt; Vector2:
    var screen_size: Vector2 = get_viewport().get_visible_rect().size
    var temp_x: float = randf() * screen_size.x - screen_size.x / 2.0
    var temp_y: float = randf() * screen_size.y - screen_size.y / 2.0

    return Vector2(temp_x, temp_y)
</code></pre>
<p>Which gets the job done, but later I&rsquo;ll have to add a way to check that the position is valid. And to actually place the food:</p>
<pre><code class="language-gdscript">func _place_new_food() -&gt; void:
    var food: Area2D = FOOD.instance()
    var position: Vector2 = _get_random_pos()
    food.global_position = position
    add_child(food)
</code></pre>
<p>And this is used in <code>_process</code> to place new food whenever needed. For now I added a condition to add food until 10 pieces are in place, and keep adding whenever the food is is lower than 10. After setting everything up, this is the result:</p>
<figure id="__yafg-figure-37">
<img alt="Snake - Food basic interaction" src="https://static.luevano.xyz/images/g/gogodot_jam3/snake_food_basic_interaction.gif" title="Snake - Food basic interaction">
<figcaption>Snake - Food basic interaction</figcaption>
</figure>
<h2 id="za-warudo-the-world">Za warudo! (The world)<a class="headerlink" href="#za-warudo-the-world" title="Permanent link">&para;</a></h2>
<p>It just happend that I saw a video to create random maps by using a method called <a href="https://www.mit.edu/~kardar/teaching/projects/chemotaxis(AndreaSchmidt)/random.htm">random walks</a>, this video was made by <a href="https://www.youtube.com/c/NADLABS">NAD LABS</a>: <a href="https://www.youtube.com/watch?v=ppP2Doq3p7s">Nuclear Throne Like Map Generation In Godot</a>. It&rsquo;s a pretty simple but powerful script, he provided the source code from which I based my random walker, just tweaked a few things and added others. Some of the maps than can be generated with this method (already aded some random sprites):</p>
<figure id="__yafg-figure-38">
<img alt="World map generator - Random map 1" src="https://static.luevano.xyz/images/g/gogodot_jam3/world_generator_1.png" title="World map generator - Random map 1">
<figcaption>World map generator - Random map 1</figcaption>
</figure>
<figure id="__yafg-figure-39">
<img alt="World map generator - Random map 2" src="https://static.luevano.xyz/images/g/gogodot_jam3/world_generator_2.png" title="World map generator - Random map 2">
<figcaption>World map generator - Random map 2</figcaption>
</figure>
<figure id="__yafg-figure-40">
<img alt="World map generator - Random map 3" src="https://static.luevano.xyz/images/g/gogodot_jam3/world_generator_3.png" title="World map generator - Random map 3">
<figcaption>World map generator - Random map 3</figcaption>
</figure>
<p>It started with just black and white tiles, but I ended up adding some sprites as it was really harsh to the eyes. My implementation is basically the same as <em>NAD LABS</em>&lsquo; with few changes, most importantly: I separated the generation in 2 diferent tilemaps (floor and wall) to have better control as well as wrapped everything in a single scene with a &ldquo;main&rdquo; script with the following important functions:</p>
<pre><code class="language-gdscript">func get_valid_map_coords() -&gt; Array:
    var safe_area: Array = walker_head.get_cells_around()
    var cells_used: Array = ground_tilemap.get_used_cells()
    for location in safe_area:
        cells_used.erase(location)
    return cells_used


func get_centered_world_position(location: Vector2) -&gt; Vector2:
    return ground_tilemap.map_to_world(location) + Vector2.ONE * Global.TILE_SIZE / 2.0
</code></pre>
<p>Where <code>get_cells_around</code> is just a function that gets the safe cells around the origin. And this <code>get_valid_map_coords</code> just returns used cells minus the safe cells, to place food. <code>get_centered_world_position</code> is so we can center the food in the tiles.</p>
<p>Some signals I used for the world gen: <code>world_gen_walker_started(id)</code>, <code>world_gen_walker_finished(id)</code>, <code>world_gen_walker_died(id)</code> and <code>world_gen_spawn_walker_unit(location)</code>.</p>
<h3 id="food-placement">Food placement<a class="headerlink" href="#food-placement" title="Permanent link">&para;</a></h3>
<p>The last food algorithm doesn&rsquo;t check anything related to the world, and thus the food could spawn in the walls and outside the map.</p>
<p>First thing is I generalized the food into a single script and added basic food and special food which inherit from base food. The most important stuff for the base food is to be able to set all necessary properties at first:</p>
<pre><code class="language-gdscript">func update_texture() -&gt; void:
    _sprite.texture = texture[properties[&quot;type&quot;]]


func set_properties(pos: Vector2, loc: Vector2, special: bool, type: int, points: int=1, special_points: int=1, ttl: float = -1.0) -&gt; void:
    properties[&quot;global_position&quot;] = pos
    global_position = pos
    properties[&quot;location&quot;] = loc
    properties[&quot;special&quot;] = special
    properties[&quot;type&quot;] = type

    properties[&quot;points&quot;] = points
    properties[&quot;special_points&quot;] = special_points
    properties[&quot;ttl&quot;] = ttl
    if properties[&quot;ttl&quot;] != -1.0:
        timer.wait_time = properties[&quot;ttl&quot;]
        timer.start()
</code></pre>
<p>Where the <code>update_texture</code> needs to be a separate function, because we need to create the food first, set properties, add as a child and then update the sprite; we also need to keep track of the global position, location (in tilemap coordinates) and identifiers for the type of food.</p>
<p>Then basic/special food just extend base food, define a <code>Type</code> enum and preloads the necessary textures, for example:</p>
<pre><code class="language-gdscript">enum Type {
    APPLE,
    BANANA,
    RAT
}


func _ready():
    texture[Type.APPLE] = preload(&quot;res://entities/food/sprites/apple.png&quot;)
    texture[Type.BANANA] = preload(&quot;res://entities/food/sprites/banana.png&quot;)
    texture[Type.RAT] = preload(&quot;res://entities/food/sprites/rat.png&quot;)
</code></pre>
<p>Now, some of the most important change to <code>food_manager.gd</code> is to get an actual random valid position:</p>
<pre><code class="language-gdscript">func _get_random_pos() -&gt; Array:
    var found_valid_loc: bool = false
    var index: int
    var location: Vector2

    while not found_valid_loc:
        index = randi() % possible_food_locations.size()
        location = possible_food_locations[index]
        if current_basic_food.find(location) == -1 and current_special_food.find(location) == -1:
            found_valid_loc = true

    return [world_generator.get_centered_world_position(location), location]
</code></pre>
<p>Other than that, there are some differences between placing normal and special food (specially the signal they send, and if an extra &ldquo;special points&rdquo; property is set). Some of the signals that I used that might be important: <code>food_placing_new_food(type)</code>, <code>food_placed_new_food(type, location)</code> and <code>food_eaten(type, location)</code>.</p>
<h2 id="stats-clas-and-loadingsaving-data">Stats clas and loading/saving data<a class="headerlink" href="#stats-clas-and-loadingsaving-data" title="Permanent link">&para;</a></h2>
<p>I got the idea of saving the current stats (points, max body segments, etc.) in a separate <code>Stats</code> class for easier load/save data. This option I went with didn&rsquo;t work as I would liked it to work, as it was a pain in the ass to setup and each time a new property is added you have to manually setup the load/save helper functions&hellip; so not the best option. This option I used was json but saving a Node directly could work better or using resources (saving <code>tres</code> files).</p>
<h3 id="stats-class">Stats class<a class="headerlink" href="#stats-class" title="Permanent link">&para;</a></h3>
<p>The <code>Stats</code> &ldquo;class&rdquo; is just a script that extends from <em>Node</em> called <code>stats.gd</code>. It needs to define the <code>class_name</code> as <code>Stats</code>. The main content:</p>
<pre><code class="language-gdscript"># main
var points: int = 0
var segments: int = 0

# track of trait points
var dash_points: int = 0
var slow_points: int = 0
var jump_points: int = 0

# times trait achieved
var dash_segments: int = 0
var slow_segments: int = 0
var jump_segments: int = 0

# trait properties
var dash_percentage: float = 0.0
var slow_percentage: float = 0.0
var jump_lenght: float = 0.0

# trait active
var trait_dash: bool = false
var trait_slow: bool = false
var trait_jump: bool = false
</code></pre>
<p>And with the ugliest functions:</p>
<pre><code class="language-gdscript">func get_stats() -&gt; Dictionary:
    return {
        &quot;points&quot;: points,
        &quot;segments&quot;: segments,
        &quot;dash_points&quot;: dash_points,
        &quot;dash_segments&quot;: dash_segments,
        &quot;dash_percentage&quot;: dash_percentage,
        &quot;slow_points&quot;: slow_points,
        &quot;slow_segments&quot;: slow_segments,
        &quot;slow_percentage&quot;: slow_percentage,
        &quot;jump_points&quot;: jump_points,
        &quot;jump_segments&quot;: jump_segments,
        &quot;jump_lenght&quot;: jump_lenght,
        &quot;trait_dash&quot;: trait_dash,
        &quot;trait_slow&quot;: trait_slow,
        &quot;trait_jump&quot;: trait_jump
    }


func set_stats(stats: Dictionary) -&gt; void:
        points = stats[&quot;points&quot;]
        segments = stats[&quot;segments&quot;]
        dash_points = stats[&quot;dash_points&quot;]
        slow_points = stats[&quot;slow_points&quot;]
        jump_points = stats[&quot;jump_points&quot;]
        dash_segments = stats[&quot;dash_segments&quot;]
        slow_segments = stats[&quot;slow_segments&quot;]
        jump_segments = stats[&quot;jump_segments&quot;]
        dash_percentage = stats[&quot;dash_percentage&quot;]
        slow_percentage = stats[&quot;slow_percentage&quot;]
        jump_lenght = stats[&quot;jump_lenght&quot;]
        trait_dash = stats[&quot;trait_dash&quot;]
        trait_slow = stats[&quot;trait_slow&quot;]
        trait_jump = stats[&quot;trait_jump&quot;]
</code></pre>
<p>And this is not scalable at all, but I had to do this at the end of the jam so no way of optimizing and/or doing it correctly, sadly.</p>
<h3 id="loadsave-data">Load/save data<a class="headerlink" href="#loadsave-data" title="Permanent link">&para;</a></h3>
<p>The load/save function is pretty standard. It&rsquo;s a singleton/autoload called <code>SavedData</code> with a script that extends from <em>Node</em> called <code>save_data.gd</code>:</p>
<pre><code class="language-gdscript">const DATA_PATH: String = &quot;user://data.save&quot;

var _stats: Stats


func _ready() -&gt; void:
    _load_data()


# called when setting &quot;stats&quot; and thus saving
func save_data(stats: Stats) -&gt; void:
    _stats = stats
    var file: File = File.new()
    file.open(DATA_PATH, File.WRITE)
    file.store_line(to_json(_stats.get_stats()))
    file.close()


func get_stats() -&gt; Stats:
    return _stats


func _load_data() -&gt; void:
    # create an empty file if not present to avoid error while loading settings
    _handle_new_file()

    var file = File.new()
    file.open(DATA_PATH, File.READ)
    _stats = Stats.new()
    _stats.set_stats(parse_json(file.get_line()))
    file.close()


func _handle_new_file() -&gt; void:
    var file: File = File.new()
    if not file.file_exists(DATA_PATH):
        file.open(DATA_PATH, File.WRITE)
        _stats = Stats.new()
        file.store_line(to_json(_stats.get_stats()))
        file.close()
</code></pre>
<p>It uses json as the file format, but I might end up changing this in the future to something else more reliable and easier to use (<code>Stats</code> class related issues).</p>
<h2 id="scoring">Scoring<a class="headerlink" href="#scoring" title="Permanent link">&para;</a></h2>
<p>For this I created a scoring mechanisms and just called it <code>ScoreManager</code> (<code>score_manager.gd</code>) which just basically listens to <code>food_eaten</code> signal and adds points accordingly to the current <em>Stats</em> object loaded. The main function is:</p>
<pre><code class="language-gdscript">func _on_food_eaten(properties: Dictionary) -&gt; void:
    var is_special: bool = properties[&quot;special&quot;]
    var type: int = properties[&quot;type&quot;]
    var points: int = properties[&quot;points&quot;]
    var special_points: int = properties[&quot;special_points&quot;]
    var location: Vector2 = properties[&quot;global_position&quot;]
    var amount_to_grow: int
    var special_amount_to_grow: int

    amount_to_grow = _process_points(points)
    _spawn_added_score_text(points, location)
    _spawn_added_segment_text(amount_to_grow)

    if is_special:
        special_amount_to_grow = _process_special_points(special_points, type)
        # _spawn_added_score_text(points, location)
        _spawn_added_special_segment_text(special_amount_to_grow, type)
        _check_if_unlocked(type)
</code></pre>
<p>Where the most important function is:</p>
<pre><code class="language-gdscript">func _process_points(points: int) -&gt; int:
    var score_to_grow: int = (stats.segments + 1) * Global.POINTS_TO_GROW - stats.points
    var amount_to_grow: int = 0
    var growth_progress: int
    stats.points += points
    if points &gt;= score_to_grow:
        amount_to_grow += 1
        points -= score_to_grow
        # maybe be careful with this
        amount_to_grow += points / Global.POINTS_TO_GROW
        stats.segments += amount_to_grow
        Event.emit_signal(&quot;snake_add_new_segment&quot;, amount_to_grow)

    growth_progress = Global.POINTS_TO_GROW - ((stats.segments + 1) * Global.POINTS_TO_GROW - stats.points)
    Event.emit_signal(&quot;snake_growth_progress&quot;, growth_progress)
    return amount_to_grow
</code></pre>
<p>Which will add the necessary points to <code>Stats.points</code> and return the amount of new snake segments to grow. After this <code>_spawn_added_score_segment</code> and <code>_spawn_added_segment_text</code> just spawn a <em>Label</em> with the info on the points/segments gained; this is custom UI I created, nothing fancy.</p>
<p>Last thing is taht in <code>_process_points</code> there is a check at the end, where if the food eaten is &ldquo;special&rdquo; then a custom variation of the last 3 functions are executed. These are really similar, just specific to each kind of food.</p>
<p>This <code>ScoreManager</code> also handles the calculation for the <code>game_over</code> signal, to calculte progress, set necessary <code>Stats</code> values and save the data:</p>
<pre><code class="language-gdscript">func _on_game_over() -&gt; void:
    var max_stats: Stats = _get_max_stats()
    SaveData.save_data(max_stats)
    Event.emit_signal(&quot;display_stats&quot;, initial_stats, stats, mutation_stats)


func _get_max_stats() -&gt; Stats:
    var old_stats_dict: Dictionary = initial_stats.get_stats()
    var new_stats_dict: Dictionary = stats.get_stats()
    var max_stats: Stats = Stats.new()
    var max_stats_dict: Dictionary = max_stats.get_stats()
    var bool_stats: Array = [
        &quot;trait_dash&quot;,
        &quot;trait_slow&quot;,
        &quot;trait_jump&quot;
    ]

    for i in old_stats_dict:
        if bool_stats.has(i):
            max_stats_dict[i] = old_stats_dict[i] or new_stats_dict[i]
        else:
            max_stats_dict[i] = max(old_stats_dict[i], new_stats_dict[i])
    max_stats.set_stats(max_stats_dict)
    return max_stats
</code></pre>
<p>Then this sends a signal <code>display_stats</code> to activate UI elements that shows the progression.</p>
<p>Naturally, the saved <code>Stats</code> are loaded whenever needed. For example, for the <code>Snake</code>, we load the stats and setup any value needed from there (like a flag to know if any ability is enabled), and since we&rsquo;re saving the new <code>Stats</code> at the end, then on restart we load the updated one.</p>
<h2 id="snake-redesigned-with-the-state-machine-pattern">Snake redesigned with the state machine pattern<a class="headerlink" href="#snake-redesigned-with-the-state-machine-pattern" title="Permanent link">&para;</a></h2>
<p>I redesigned the snake code (the head, actually) to use the state machine pattern by following <a href="https://gdscript.com/solutions/godot-state-machine/">this guide</a> which is definitely a great guide, straight to the point and easy to implement.</p>
<p>Other than what is shown in the guide, I implemented some important functions in the <code>state_machine.gd</code> script itself, to be used by each of the states as needed:</p>
<pre><code class="language-gdscript">func rotate_on_input() -&gt; void:
    if Input.is_action_pressed(&quot;move_left&quot;):
        player.rotate_to(player.LEFT)
    if Input.is_action_pressed(&quot;move_right&quot;):
        player.rotate_to(player.RIGHT)


func slow_down_on_collisions(speed_backup: float):
    if player.get_last_slide_collision():
        Global.SNAKE_SPEED = player.velocity.length()
    else:
        Global.SNAKE_SPEED = speed_backup


func handle_slow_speeds() -&gt; void:
    if Global.SNAKE_SPEED &lt;= Global.SNAKE_SPEED_BACKUP / 4.0:
        Global.SNAKE_SPEED = Global.SNAKE_SPEED_BACKUP
        Event.emit_signal(&quot;game_over&quot;)
</code></pre>
<p>And then in the <code>StateMachine</code>&lsquo;s <code>_process</code>:</p>
<pre><code class="language-gdscript">func _physics_process(delta: float) -&gt; void:
    # state specific code, move_and_slide is called here
    if state.has_method(&quot;physics_process&quot;):
        state.physics_process(delta)

    handle_slow_speeds()
    player.handle_time_elapsed(delta)
</code></pre>
<p>And now it&rsquo;s just a matter of implementing the necessary states. I used 4: <code>normal_stage.gd</code>, <code>slow_state.gd</code>, <code>dash_state.gd</code> and <code>jump_state.gd</code>.</p>
<p>The <code>normal_state.gd</code> contains what the original <code>head.gd</code> code contained:</p>
<pre><code class="language-gdscript">func physics_process(delta: float) -&gt; void:
    fsm.rotate_on_input()
    fsm.player.velocity = fsm.player.direction * Global.SNAKE_SPEED
    fsm.player.velocity = fsm.player.move_and_slide(fsm.player.velocity)

    fsm.slow_down_on_collisions(Global.SNAKE_SPEED_BACKUP)


func input(event: InputEvent) -&gt; void:
    if fsm.player.can_dash and event.is_action_pressed(&quot;dash&quot;):
        exit(&quot;DashState&quot;)
    if fsm.player.can_slow and event.is_action_pressed(&quot;slow&quot;):
        exit(&quot;SlowState&quot;)
    if fsm.player.can_jump and event.is_action_pressed(&quot;jump&quot;):
        exit(&quot;JumpState&quot;)
</code></pre>
<p>Here, the <code>exit</code> method is basically to change to the next state. And lastly, I&rsquo;m only gonna show the <code>dash_state.gd</code> as the other ones are pretty similar:</p>
<pre><code class="language-gdscript">func enter():
    if fsm.DEBUG:
        print(&quot;Got inside %s.&quot; % name)
    Event.emit_signal(&quot;snake_started_dash&quot;)
    Global.SNAKE_SPEED = Global.SNAKE_DASH_SPEED
    yield(get_tree().create_timer(Global.SNAKE_DASH_TIME), &quot;timeout&quot;)
    exit()


func exit():
    Event.emit_signal(&quot;snake_finished_dash&quot;)
    Global.SNAKE_SPEED = Global.SNAKE_SPEED_BACKUP
    fsm.back()


func physics_process(delta: float) -&gt; void:
    fsm.rotate_on_input()
    fsm.player.velocity = fsm.player.direction * Global.SNAKE_SPEED
    fsm.player.velocity = fsm.player.move_and_slide(fsm.player.velocity)

    fsm.slow_down_on_collisions(Global.SNAKE_DASH_SPEED)
</code></pre>
<p>Where the important parts happen in the <code>enter</code> and <code>exit</code> functions. We need to change the <code>Global.SNAKE_SPEED</code> with the <code>Global.SNAKE_DASH_SPEED</code> on <code>start</code>and start the timer for how long should the dash last. And on the <code>exit</code> we reset the <code>Global.SNAKE_SPEED</code> back to normal. There is probably a better way of updating the <code>Global.SNAKE_SPEED</code> but this works just fine.</p>
<p>For the other ones is the same. Only difference with the <code>jump_state.gd</code> is that the collision from head to body is disabled, and no rotation is allowed (by not calling the <code>rotate_on_input</code> function).</p>
<h2 id="other-minor-stuff">Other minor stuff<a class="headerlink" href="#other-minor-stuff" title="Permanent link">&para;</a></h2>
<p>Not as important but worth mentioning:</p>
<ul>
<li>Added restartability function.</li>
<li>Added signals for game control: <code>game_over</code> and <code>game_start</code>, but ended not using them.</li>
<li>Fixed issue where the <em>Curve2D</em> stayed the same even when restarting by just setting an empty curve on starting the node.</li>
<li>Added a debug mode for drawing of the <em>Curve2D</em> instead of always drawing.</li>
<li>Tweaked the tracking of the snake size.</li>
<li>Tweaked the food system to contain more attributes and use a base food node.</li>
<li>Added a HUD with mini snake sprites.</li>
<li>Added a HUD for growth progress on snake body segments and abilities.</li>
<li>Refactored the nodes to make it work with <code>change_scene_to</code>, and added a main menu.</li>
<li>Added GUI for dead screen, showing the progress.</li>
</ul>
<h2 id="final-notes">Final notes<a class="headerlink" href="#final-notes" title="Permanent link">&para;</a></h2>
<p>I actually didn&rsquo;t finish this game (as how I visualized it), but I got it in a <em>semi-playable</em> state which is good. My big learning during this jam is the time management that it requires to plan and design a game. I lost a lot of time trying to implement some mechanics because I was facing many issues, because of my lack of practice (which was expected) as well as trying to blog and create the necessary sprites myself. Next time I should just get an asset pack and do something with it, as well as keeping the scope of my game shorter.</p>
<p>For exporting and everything else, I went with what I did for my <a href="https://blog.luevano.xyz/g/flappybird_godot_devlog_1#final-notes-and-exporting">FlappyBird Godot clone: final notes and exporting</a></p>

  <div class="page-nav">
    <span class="next">
      <a href="https://blog.luevano.xyz/a/rewrote_pyssg_again.html" alt="Next">
        <i class="fas fa-arrow-left" alt="Arrow left"></i>
        <span>Next</span>
      </a>
    </span>

    <span class="index">
      <a href="https://blog.luevano.xyz" alt="Index">
        <i class="fas fa-home" alt="Home"></i>
        <span>Index</span>
      </a>
    </span>

    <span class="previous">
      <a href="https://blog.luevano.xyz/g/flappybird_godot_devlog_1.html" alt="Previous">
        <i class="fas fa-arrow-right" alt="Arrow right"></i>
        <span>Previous</span>
      </a>
    </span>
</div>


  <hr>
  <div class="article-info">
    <p>By David Luévano</p>
    <p>Created: Fri, Jun 10, 2022 @ 09:17 UTC</p>
      <p>Modified: Thu, May 04, 2023 @ 17:05 UTC</p>
    <div class="article-tags">
  <p>Tags:
<a href="https://blog.luevano.xyz/tag/@english.html">english</a>, <a href="https://blog.luevano.xyz/tag/@gamedev.html">gamedev</a>, <a href="https://blog.luevano.xyz/tag/@gamejam.html">gamejam</a>, <a href="https://blog.luevano.xyz/tag/@gdscript.html">gdscript</a>, <a href="https://blog.luevano.xyz/tag/@godot.html">godot</a>  </p>
</div>

  </div>
    </main>

    <footer>
<span>
  <i class="fas fa-address-card" alt="Contact"></i>
  <a href="https://blog.luevano.xyz/contact.html">Contact</a>
</span>

<span>
  <i class="fas fa-donate" alt="Donate"></i>
  <a href="https://blog.luevano.xyz/donate.html">Donate</a>
</span>

<span>
  <i class="fas fa-rss" alt="RSS"></i>
  <a target="_blank" href="https://blog.luevano.xyz/rss.xml">RSS</a>
</span>

<br>
<span class="created-with">
  <i class="fas fa-hammer" alt="Hammer"></i>
  Created with <a href="https://github.com/luevano/pyssg">pyssg</a>
</span>

<br>
<span class="copyright">
  Copyright <i class="far fa-copyright" alt="Copyright"></i> 2023 David Luévano Alvarado
</span>

    </footer>
  </body>
</html>